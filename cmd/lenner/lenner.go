package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/ngicks/type-param-common/slice"
)

const autoGenerationNotice = "// Code generated by github.com/ngicks/type-param-common/cmd/lenner. DO NOT EDIT."

var (
	inputDir = flag.String("i", ".", "input dir.")
	targetTy = flag.String("ty", "DeIterator", "target type.")
	ignore   = flag.String("ignore", "lenner.go", "ignored filename list. comma-seperated")
	outFile  = flag.String("o", "", "out filename. if empty, all output goes to stdout.")
)

func main() {
	if err := _main(); err != nil {
		panic(err)
	}
}

func _main() error {
	flag.Parse()

	content, err := readDir(*inputDir)
	if err != nil {
		return err
	}

	fset := token.NewFileSet()

	var packageName string

	templateParams := make([]TemplateParam, 0)

	for _, filename := range content {
		file, err := os.Open(filename)
		if err != nil {
			return err
		}
		pName, tmplParam, err := getTemplateParam(fset, filename, file)
		if err != nil {
			return err
		}
		if pName != "" && !strings.HasSuffix(pName, "_test") {
			packageName = pName
		}

		if tmplParam != nil {
			templateParams = append(templateParams, tmplParam...)
		}
	}

	var out io.Writer
	if *outFile == "" {
		out = os.Stdout
	} else {
		out, err = os.Create(*outFile)
		if err != nil {
			return err
		}
	}
	return executeLennerTemplate(out, packageName, templateParams)
}

func readDir(dir string) (content []string, err error) {
	dirents, err := os.ReadDir(dir)
	if err != nil {
		return
	}

	for _, v := range dirents {
		if !v.Type().IsRegular() {
			continue
		}
		content = append(content, filepath.Join(dir, v.Name()))
	}
	return
}

func getTemplateParam(fset *token.FileSet, filename string, r io.Reader) (packageName string, templateParams []TemplateParam, err error) {
	ignoreList := strings.Split(*ignore, ",")
	if slice.Has(ignoreList, filepath.Base(filename)) {
		return
	}
	f, err := parser.ParseFile(fset, filepath.Base(filename), r, 0)
	if err != nil {
		panic(err)
	}

	if packageName == "" {
		packageName = f.Name.Name
	}

	ast.Inspect(f, func(n ast.Node) (goAhead bool) {
		goAhead = true

		var ok bool
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return
		}
		structTy, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return
		}
		if structTy.Fields.List == nil {
			return
		}

		for _, field := range structTy.Fields.List {
			idx, ok := field.Type.(*ast.IndexExpr)
			if !ok {
				continue
			}
			ident, ok := idx.X.(*ast.Ident)
			if !ok {
				continue
			}

			if ident.Name == *targetTy {
				var memberName string
				if len(field.Names) > 0 {
					memberName = field.Names[0].Name
				} else {
					memberName = *targetTy
				}

				t := TemplateParam{
					ReceiverName:        "iter",
					TypeName:            typeSpec.Name.Name,
					TypeParams:          getTypeParam(typeSpec),
					InnerMemberName:     memberName,
					LennerInterfaceName: "Lenner",
				}
				templateParams = append(templateParams, t)
			}
		}
		return
	})
	return
}

func getTypeParam(typeSpec *ast.TypeSpec) string {
	if typeSpec.TypeParams != nil && typeSpec.TypeParams.List != nil {
		tmplStr := make([]string, 0)
		for _, v := range typeSpec.TypeParams.List {
			if v.Names != nil {
				for _, n := range v.Names {
					tmplStr = append(tmplStr, n.Name)
				}
			}
		}
		return strings.Join(tmplStr, ",")
	}
	return ""
}

type TemplateParam struct {
	ReceiverName        string
	TypeName            string
	TypeParams          string
	InnerMemberName     string
	LennerInterfaceName string
}

var lennerTemplate = template.Must(template.New("v").Parse(`
func ({{.ReceiverName}} {{.TypeName}}[{{.TypeParams}}]) Len() int {
	if lenner, ok := {{.ReceiverName}}.{{.InnerMemberName}}.({{.LennerInterfaceName}}); ok {
		return lenner.Len()
	}
	return -1
}
`))

func executeLennerTemplate(w io.Writer, packageName string, templateParams []TemplateParam) (err error) {
	_, err = fmt.Fprintf(w, "package %s\n", packageName)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintln(w)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintln(w, autoGenerationNotice)
	if err != nil {
		return err
	}
	for _, v := range templateParams {
		err := lennerTemplate.Execute(w, v)
		if err != nil {
			return err
		}
	}
	return nil
}
